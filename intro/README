# DAY 1
#
# Defining a computer, s/w and h/w interaction.
## The computer is a digital device: it runs on electricity, but not continuous electricity,
## rather, pulses of electricity. Some pulses are high, others are low. High pulses activate
## the digital parts of the computer, and low ones do not.
## The digital device is constantly receiving such digital on-off signals, called binary signals.
## These signals are generated by the execution of binary code. 
##
## S/w, or code, is a file that contains a binary encoding.
## The contents of this file can be copied, bit by bit, to the processor component of the digital
## computer. These bits of binary code, called instructions, will activate - turn on - parts of 
## the processor, and deactivate others. This is how s/w executes.
##
## The execution of s/w produces many of the effects that we, users, see.
## The first is the OS desktop you see before you: this is just an effect of code running on the machine.
## This particular piece of code that produces a visual desktop for us to interact with is called the GUI.
## Using the GUI, we can interact with the machine to launch different other s/w, such as a web browser.
## The web browser itselt executes code of the web pages that you visit.
## NOTE: The GUI is not the OS - it is s/w code that is part of the full OS code. This s/w detects your input,
## like keyboard presses and mouse clicks, and sents messages to the OS telling it to perform the
## actions that your inputs mean: e.g. a mouse double-click runs something.
## The OS is another example of code running to produce desired effects on the machine we are using.
## In fact, the OS is the most important piece of code for any machine. It runs the machine.
##
## The journey of the OS: on power on -> from firmware to memory - i.e. RAM -> from RAM to processor,
## as needed - i.e. screen driver code runs when displaying to screen is needed, process creation
## code runs when a new s/w is to be run.
## The OS is always running, ready to run any other s/w, and multitasking the many s/w you need to run.
#
# Defining Virtualization: Using a different OS: Linux
## In the simplest terms, the current OS Windows will run the Linux OS as one of its processes.
## Using Linux, we can explore the meaning of different OS constructs more easily.
#
# ...
########
# DAY 2
#
# Defining a PL, Python, how Python code runs
## Defining a PL: a language for writing code
## Defining code: instructions + data
## Defining instructions in code: basic arithmetic operations + functions.
## Defining data: characters, strings, numeric data
## In any PL: defining variables, defining functions, using variables in functions, calling functions
## In any PL: syntax rules and vocabulary
## In any PL: translation to binary encoding
## Writing Python scripts: interpreted scripts, one line at a time
## Calling print function: function name and arguments: string.
## Python greeting variable: variable name and value.
## Try integer variable, concatenation with string - example of basic operation vs. function call.
## Defining say_hello function: function name and no arguments
## Calling a function within a function.
## NOTE: Using user-defined functions and global data.
## 
## hello.py, hello_function.py, my_hello.py
########
# DAY 3
#
# Using C
## in C, we can see the final binary product from the translation process because C is compiled
# Execution: how binary code runs - i.e. loading to memory, binary instructions fetch-execute loop.
## in C, we can trace the execution of the binary code using a debugger
# User Interaction: how do we end up seeing the result of execution.
## in C, we can see in the final binary the code for many pre-built functions added to do this
#
# Observing the process of code translation and execution in C and GDB.
# C concepts, hidden in Python: 
## ASCII encoding is made explicit more frequently in C
## 
# GDB: using a debugger.

